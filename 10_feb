@app.get("/traceability/search")
def search_traceability_records(query: str = Query(None), db: Session = Depends(init_db)):
    if not query:
        # Return empty or top 10 recent if no query
        return {"results": []}
    
    search_term = f"%{query}%"
    
    # Search across multiple fields from QRRecord_Generated
    results = db.query(QRRecord_Generated).filter(
        or_(
            QRRecord_Generated.Reference_No.ilike(search_term),
            QRRecord_Generated.BEL_Part_Number.ilike(search_term),
            QRRecord_Generated.Vendor_Name.ilike(search_term),
            QRRecord_Generated.Description.ilike(search_term),
            QRRecord_Generated.BEL_PO_No.ilike(search_term),
            QRRecord_Generated.GR_No.ilike(search_term)
        )
    ).limit(50).all() # Limit results for performance

    # Format response for frontend Autocomplete
    formatted_results = [
        {
            "label": f"{r.Reference_No} | {r.BEL_Part_Number} | {r.Vendor_Name}",
            "value": r.Reference_No
        } for r in results
    ]
    
    return {"results": formatted_results}

___________________________________________________


const [searchTerm, setSearchTerm] = useState("");
const [options, setOptions] = useState([]);

// Fetch options when user types
useEffect(() => {
  const delayDebounceFn = setTimeout(async () => {
    if (searchTerm.length > 2) {
      try {
        const response = await axios.get(`http://192.168.0.20:2000/traceability/search?query=${searchTerm}`);
        setOptions(response.data.results);
      } catch (err) {
        console.error("Search failed", err);
      }
    }
  }, 300); // Debounce to prevent too many API calls

  return () => clearTimeout(delayDebounceFn);
}, [searchTerm]);

// In the return() section:
<Autocomplete
  sx={{ width: 500 }}
  options={options}
  getOptionLabel={(option) => option.label || ""}
  onInputChange={(event, newInputValue) => {
    setSearchTerm(newInputValue);
  }}
  onChange={(event, newValue) => {
    if (newValue) {
      setSelectedRef(newValue.value); // Use Reference_No for fetching details
      fetchTraceability(newValue.value);
    }
  }}
  // Makes the list scrollable and limits height
  ListboxProps={{
    style: {
      maxHeight: '300px',
      overflow: 'auto',
    },
  }}
  renderInput={(params) => (
    <TextField 
      {...params} 
      label="Search by Part No, Vendor, PO, or Ref No" 
      variant="outlined" 
    />
  )}
/>


___________________________________________________



To secure a FastAPI application, you can implement either token-based authentication (JWT) or API key mechanisms. While both serve to verify access, they are used in different contexts: tokens are ideal for user sessions, while API keys are better suited for machine-to-machine or third-party integrations.
1. Token-Based Authentication (JWT)
Token-based authentication typically uses JSON Web Tokens (JWT). It follows a flow where a user exchanges their credentials (username/password) for a temporary token.
 * How it works:
   * Login: The user sends credentials to a /token endpoint.
   * Verification: The server verifies the credentials and returns an encoded JWT.
   * Authorization: For subsequent requests, the client sends this token in the Authorization header as a Bearer token.
   * Validation: FastAPI intercepts the request, decodes the JWT using a secret key, and checks the expiration.
 * FastAPI Implementation:
   FastAPI provides the OAuth2PasswordBearer class to automate the extraction of the token from the request header.
   from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.get("/items/")
async def read_items(token: str = Depends(oauth2_scheme)):
    return {"token": token}

2. API Key Mechanisms
API keys are simpler, usually static strings passed in the request header, query parameters, or cookies. They are often long-lived and identify a specific "application" rather than an individual human user session.
 * Key Locations:
   * Header: X-API-Key: your_secret_key (Most secure and standard).
   * Query String: ?api_key=your_secret_key (Easier to use but can be logged in server history).
   * Cookie: Useful for browser-based tool integrations.
 * FastAPI Implementation:
   FastAPI uses APIKeyHeader, APIKeyQuery, or APIKeyCookie from fastapi.security to define these requirements.
   from fastapi import Security, HTTPException, status
from fastapi.security import APIKeyHeader

API_KEY = "my_super_secret_key"
api_key_header = APIKeyHeader(name="X-API-Key")

async def get_api_key(api_key: str = Security(api_key_header)):
    if api_key == API_KEY:
        return api_key
    raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)

Comparison Summary
| Feature | Token-Based (JWT) | API Key |
|---|---|---|
| Primary Use | User-specific sessions/Frontend apps | Server-to-server / Third-party access |
| Lifespan | Short-lived (e.g., 30 mins) | Long-lived (until rotated) |
| Payload | Can store user data (ID, Roles) | Usually just a unique identifier |
| Complexity | Higher (requires signing/decoding) | Lower (simple string match) |
Best Practices for Security
 * Use HTTPS: Both mechanisms transmit secrets that can be intercepted on non-encrypted connections.
 * Environment Variables: Never hardcode your SECRET_KEY or API_KEY. Use .env files.
 * Rotation: Implement a way to revoke or rotate keys if they are compromised.
 * Hashing: For API keys, store a hashed version in your database (like a password) rather than the plain text.
Secure FastAPI API with JWT (OAuth2)
This video provides a step-by-step tutorial on implementing JWT token authentication and OAuth2 in FastAPI, which is essential for understanding the practical setup of the token-based flow described above.

YouTube video views will be stored in your YouTube History, and your data will be stored and used by YouTube according to its Terms of Service

___________________________________________________



To implement authentication in your Data_Server.py, you should follow the JWT (JSON Web Token) pattern, which is the industry standard for FastAPI. Based on your current code, you already have a UserProfile table with a password field in Database_models.py, which is the perfect foundation.
Here are the changes required to secure your server:
1. Install Dependencies
You will need to install libraries for password hashing and token generation:
pip install "python-jose[cryptography]" "passlib[bcrypt]" python-multipart

2. Update Data_Server.py (Authentication Logic)
Add the following security configuration at the top of your file. This includes password hashing and the logic to generate/verify JWT tokens.
import os
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

# Configuration
SECRET_KEY = "YOUR_SUPER_SECRET_KEY" # In production, use os.getenv("SECRET_KEY")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Helper Functions
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

# Dependency to protect routes
async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(init_db)):
    credentials_exception = HTTPException(status_code=401, detail="Could not validate credentials")
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
        
    user = db.query(UserProfile).filter(UserProfile.userID == user_id).first()
    if user is None:
        raise credentials_exception
    return user

3. Add Authentication Endpoints
Add these routes to handle logging in and retrieving the current user's profile.
@app.post("/token")
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(init_db)):
    user = db.query(UserProfile).filter(UserProfile.userID == form_data.username).first()
    if not user or not verify_password(form_data.password, user.password):
        raise HTTPException(status_code=401, detail="Incorrect username or password")
    
    access_token = create_access_token(data={"sub": user.userID})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me")
async def read_users_me(current_user: UserProfile = Depends(get_current_user)):
    return {
        "userID": current_user.userID,
        "username": current_user.username,
        "userRole": current_user.userRole,
        "sbu": current_user.sbu
    }

4. Secure Existing Routes
To protect any sensitive route (like reset_all or updatedetails), simply add current_user: UserProfile = Depends(get_current_user) to the function parameters.
Example: Protecting the Reset Route
@app.delete("/admin/reset_all")
def reset_all(
    db: Session = Depends(init_db), 
    current_user: UserProfile = Depends(get_current_user) # Now requires a valid token
):
    # Check if the user is actually an admin
    if current_user.admin != "Yes":
        raise HTTPException(status_code=403, detail="Not enough permissions")
    
    # ... rest of your reset logic

Summary of Improvements:
 * Password Hashing: Replaces plain-text passwords with secure bcrypt hashes.
 * JWT Tokens: Users get a temporary "pass" (token) after logging in, so they don't have to send their password with every request.
 * Role-Based Access: You can now easily check if current_user.userRole or current_user.admin matches the required permission for a specific action.
 * Standardized Flow: Uses FastAPI's built-in OAuth2PasswordBearer, which automatically integrates with the Swagger UI /docs "Authorize" button.
