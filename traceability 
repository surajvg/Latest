@app.get("/traceability/search")
def search_traceability_records(query: str = Query(None), db: Session = Depends(init_db)):
    if not query:
        # Return empty or top 10 recent if no query
        return {"results": []}
    
    search_term = f"%{query}%"
    
    # Search across multiple fields from QRRecord_Generated
    results = db.query(QRRecord_Generated).filter(
        or_(
            QRRecord_Generated.Reference_No.ilike(search_term),
            QRRecord_Generated.BEL_Part_Number.ilike(search_term),
            QRRecord_Generated.Vendor_Name.ilike(search_term),
            QRRecord_Generated.Description.ilike(search_term),
            QRRecord_Generated.BEL_PO_No.ilike(search_term),
            QRRecord_Generated.GR_No.ilike(search_term)
        )
    ).limit(50).all() # Limit results for performance

    # Format response for frontend Autocomplete
    formatted_results = [
        {
            "label": f"{r.Reference_No} | {r.BEL_Part_Number} | {r.Vendor_Name}",
            "value": r.Reference_No
        } for r in results
    ]
    
    return {"results": formatted_results}

___________________________________________________



const [searchTerm, setSearchTerm] = useState("");
const [options, setOptions] = useState([]);

// Fetch options when user types
useEffect(() => {
  const delayDebounceFn = setTimeout(async () => {
    if (searchTerm.length > 2) {
      try {
        const response = await axios.get(`http://192.168.0.20:2000/traceability/search?query=${searchTerm}`);
        setOptions(response.data.results);
      } catch (err) {
        console.error("Search failed", err);
      }
    }
  }, 300); // Debounce to prevent too many API calls

  return () => clearTimeout(delayDebounceFn);
}, [searchTerm]);

// In the return() section:
<Autocomplete
  sx={{ width: 500 }}
  options={options}
  getOptionLabel={(option) => option.label || ""}
  onInputChange={(event, newInputValue) => {
    setSearchTerm(newInputValue);
  }}
  onChange={(event, newValue) => {
    if (newValue) {
      setSelectedRef(newValue.value); // Use Reference_No for fetching details
      fetchTraceability(newValue.value);
    }
  }}
  // Makes the list scrollable and limits height
  ListboxProps={{
    style: {
      maxHeight: '300px',
      overflow: 'auto',
    },
  }}
  renderInput={(params) => (
    <TextField 
      {...params} 
      label="Search by Part No, Vendor, PO, or Ref No" 
      variant="outlined" 
    />
  )}
/>

___________________________________________________



To secure a FastAPI application, you can implement either token-based authentication (JWT) or API key mechanisms. While both serve to verify access, they are used in different contexts: tokens are ideal for user sessions, while API keys are better suited for machine-to-machine or third-party integrations.
1. Token-Based Authentication (JWT)
Token-based authentication typically uses JSON Web Tokens (JWT). It follows a flow where a user exchanges their credentials (username/password) for a temporary token.
 * How it works:
   * Login: The user sends credentials to a /token endpoint.
   * Verification: The server verifies the credentials and returns an encoded JWT.
   * Authorization: For subsequent requests, the client sends this token in the Authorization header as a Bearer token.
   * Validation: FastAPI intercepts the request, decodes the JWT using a secret key, and checks the expiration.
 * FastAPI Implementation:
   FastAPI provides the OAuth2PasswordBearer class to automate the extraction of the token from the request header.
   from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.get("/items/")
async def read_items(token: str = Depends(oauth2_scheme)):
    return {"token": token}

2. API Key Mechanisms
API keys are simpler, usually static strings passed in the request header, query parameters, or cookies. They are often long-lived and identify a specific "application" rather than an individual human user session.
 * Key Locations:
   * Header: X-API-Key: your_secret_key (Most secure and standard).
   * Query String: ?api_key=your_secret_key (Easier to use but can be logged in server history).
   * Cookie: Useful for browser-based tool integrations.
 * FastAPI Implementation:
   FastAPI uses APIKeyHeader, APIKeyQuery, or APIKeyCookie from fastapi.security to define these requirements.
   from fastapi import Security, HTTPException, status
from fastapi.security import APIKeyHeader

API_KEY = "my_super_secret_key"
api_key_header = APIKeyHeader(name="X-API-Key")

async def get_api_key(api_key: str = Security(api_key_header)):
    if api_key == API_KEY:
        return api_key
    raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)

Comparison Summary
| Feature | Token-Based (JWT) | API Key |
|---|---|---|
| Primary Use | User-specific sessions/Frontend apps | Server-to-server / Third-party access |
| Lifespan | Short-lived (e.g., 30 mins) | Long-lived (until rotated) |
| Payload | Can store user data (ID, Roles) | Usually just a unique identifier |
| Complexity | Higher (requires signing/decoding) | Lower (simple string match) |
Best Practices for Security
 * Use HTTPS: Both mechanisms transmit secrets that can be intercepted on non-encrypted connections.
 * Environment Variables: Never hardcode your SECRET_KEY or API_KEY. Use .env files.
 * Rotation: Implement a way to revoke or rotate keys if they are compromised.
 * Hashing: For API keys, store a hashed version in your database (like a password) rather than the plain text.
Secure FastAPI API with JWT (OAuth2)
This video provides a step-by-step tutorial on implementing JWT token authentication and OAuth2 in FastAPI, which is essential for understanding the practical setup of the token-based flow described above.

YouTube video views will be stored in your YouTube History, and your data will be stored and used by YouTube according to its Terms of Service

